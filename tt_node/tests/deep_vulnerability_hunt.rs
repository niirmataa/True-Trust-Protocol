//! Deep Vulnerability Hunting - szukamy KA≈ªDEJ mo≈ºliwej luki
//! "Paranoja to zaw√≥d" - testujemy wszystko co mo≈ºe p√≥j≈õƒá ≈∫le

use tt_node::crypto::kmac_drbg::KmacDrbg;
use tt_node::falcon_sigs::{falcon_keypair, falcon_sign, falcon_verify, falcon_sk_to_bytes, falcon_pk_to_bytes};
use tt_node::kyber_kem::{kyber_keypair, kyber_encapsulate, kyber_decapsulate, kyber_ct_to_bytes, kyber_ss_to_bytes};
use rand_core::RngCore;
use std::collections::HashSet;
use pqcrypto_traits::sign::PublicKey as SignPK;

// ============================================================
// KATEGORIA 1: STATE CONFUSION ATTACKS
// ============================================================

#[test]
fn test_drbg_state_after_massive_generation() {
    let mut drbg = KmacDrbg::new(b"test_seed_for_massive_generation", b"test");
    
    let mut outputs = Vec::new();
    for i in 0..10000 {
        let mut buf = [0u8; 32];
        drbg.fill_bytes(&mut buf);
        if i % 1000 == 0 {
            outputs.push(buf);
        }
    }
    
    let unique: HashSet<_> = outputs.iter().collect();
    assert_eq!(unique.len(), outputs.len(), "DRBG powt√≥rzy≈Ç output!");
    println!("‚úÖ 10000 generacji bez powt√≥rze≈Ñ");
}

#[test]
fn test_drbg_reseed_security() {
    let mut drbg1 = KmacDrbg::new(b"initial_seed", b"pers");
    let mut drbg2 = KmacDrbg::new(b"initial_seed", b"pers");
    
    let mut buf1 = [0u8; 32];
    let mut buf2 = [0u8; 32];
    drbg1.fill_bytes(&mut buf1);
    drbg2.fill_bytes(&mut buf2);
    assert_eq!(buf1, buf2, "Identyczne seedy dajƒÖ r√≥≈ºne wyniki!");
    
    drbg2.reseed(b"new_entropy");
    
    drbg1.fill_bytes(&mut buf1);
    drbg2.fill_bytes(&mut buf2);
    assert_ne!(buf1, buf2, "Reseed nie zmieni≈Ç stanu DRBG!");
    println!("‚úÖ Reseed poprawnie zmienia stan");
}

#[test]
fn test_drbg_personalization_matters() {
    let mut drbg1 = KmacDrbg::new(b"same_seed", b"alice");
    let mut drbg2 = KmacDrbg::new(b"same_seed", b"bob");
    
    let mut buf1 = [0u8; 32];
    let mut buf2 = [0u8; 32];
    drbg1.fill_bytes(&mut buf1);
    drbg2.fill_bytes(&mut buf2);
    
    assert_ne!(buf1, buf2, "R√≥≈ºne personalizacje muszƒÖ dawaƒá r√≥≈ºne wyniki!");
    println!("‚úÖ Personalizacja tworzy r√≥≈ºne strumienie");
}

// ============================================================
// KATEGORIA 2: KEY REUSE VULNERABILITIES  
// ============================================================

#[test]
fn test_falcon_cross_verification_fails() {
    let (pk, sk) = falcon_keypair();
    
    let msg1 = [1u8; 32];
    let sig1 = falcon_sign(&msg1, &sk).expect("sign1");
    
    let msg2 = [2u8; 32];
    let sig2 = falcon_sign(&msg2, &sk).expect("sign2");
    
    assert!(falcon_verify(&msg1, &sig1, &pk).is_ok());
    assert!(falcon_verify(&msg2, &sig2, &pk).is_ok());
    
    assert!(falcon_verify(&msg2, &sig1, &pk).is_err());
    assert!(falcon_verify(&msg1, &sig2, &pk).is_err());
    println!("‚úÖ Cross-verification poprawnie fails");
}

#[test]
fn test_kyber_unique_encapsulations() {
    let (pk, sk) = kyber_keypair();
    
    let mut secrets = Vec::new();
    let mut cts = Vec::new();
    
    for _ in 0..100 {
        let (ss, ct) = kyber_encapsulate(&pk);
        secrets.push(kyber_ss_to_bytes(&ss).to_vec());
        cts.push(kyber_ct_to_bytes(&ct).to_vec());
    }
    
    let unique_ss: HashSet<_> = secrets.iter().collect();
    let unique_ct: HashSet<_> = cts.iter().collect();
    
    assert_eq!(unique_ss.len(), 100, "PowtarzajƒÖce siƒô SS!");
    assert_eq!(unique_ct.len(), 100, "PowtarzajƒÖce siƒô CT!");
    
    // Ka≈ºdy CT dekapsuluje do swojego SS
    for i in 0..100 {
        let ct = tt_node::kyber_kem::kyber_ct_from_bytes(&cts[i]).unwrap();
        let decap = kyber_decapsulate(&ct, &sk).expect("decap");
        assert_eq!(kyber_ss_to_bytes(&decap).as_slice(), &secrets[i][..]);
    }
    println!("‚úÖ 100 unikalnych encapsulacji");
}

// ============================================================
// KATEGORIA 3: ENTROPY STARVATION
// ============================================================

#[test]
fn test_low_entropy_expansion() {
    let mut weak_drbg = KmacDrbg::new(b"a", b"weak");
    
    let mut keys = Vec::new();
    for _ in 0..100 {
        let mut key = [0u8; 32];
        weak_drbg.fill_bytes(&mut key);
        keys.push(key);
    }
    
    let unique: HashSet<_> = keys.iter().collect();
    assert_eq!(unique.len(), 100, "S≈Çaby seed = powt√≥rzenia!");
    
    for key in &keys {
        let unique_bytes: HashSet<_> = key.iter().collect();
        assert!(unique_bytes.len() > 15, "Za niska entropia klucza!");
    }
    println!("‚ö†Ô∏è  KMAC rozszerza s≈Çaby seed, ale produkcja wymaga silnej entropii!");
}

#[test] 
fn test_personalization_protects() {
    let timestamp = 1732900800u64;
    let seed = timestamp.to_le_bytes();
    
    let mut drbg1 = KmacDrbg::new(&seed, b"node_123");
    let mut drbg2 = KmacDrbg::new(&seed, b"node_456");
    
    let mut buf1 = [0u8; 32];
    let mut buf2 = [0u8; 32];
    drbg1.fill_bytes(&mut buf1);
    drbg2.fill_bytes(&mut buf2);
    
    assert_ne!(buf1, buf2, "R√≥≈ºna personalizacja powinna chroniƒá!");
    println!("‚úÖ Personalizacja separuje strumienie nawet ze s≈Çabym seedem");
}

// ============================================================
// KATEGORIA 4: MALLEABILITY ATTACKS
// ============================================================

#[test]
fn test_signature_malleability() {
    let (pk, sk) = falcon_keypair();
    let msg = [0xABu8; 32];
    let sig = falcon_sign(&msg, &sk).expect("sign");
    
    let sig_bytes = tt_node::falcon_sigs::serialize_signature(&sig).expect("serialize");
    
    for bit_pos in 0..std::cmp::min(sig_bytes.len() * 8, 500) {
        let byte_pos = bit_pos / 8;
        let bit_in_byte = bit_pos % 8;
        
        let mut modified = sig_bytes.clone();
        modified[byte_pos] ^= 1 << bit_in_byte;
        
        if let Ok(modified_sig) = tt_node::falcon_sigs::deserialize_signature(&modified) {
            assert!(falcon_verify(&msg, &modified_sig, &pk).is_err(),
                "üö® MALLEABILITY at bit {}!", bit_pos);
        }
    }
    println!("‚úÖ Falcon odporne na malleability (500 bit√≥w)");
}

#[test]
fn test_ciphertext_malleability() {
    let (pk, sk) = kyber_keypair();
    let (original_ss, ct) = kyber_encapsulate(&pk);
    let original_bytes = kyber_ss_to_bytes(&original_ss);
    let ct_bytes = kyber_ct_to_bytes(&ct);
    
    for byte_pos in 0..std::cmp::min(ct_bytes.len(), 50) {
        let mut modified = ct_bytes.to_vec();
        modified[byte_pos] ^= 0xFF;
        
        if let Ok(modified_ct) = tt_node::kyber_kem::kyber_ct_from_bytes(&modified) {
            let decap = kyber_decapsulate(&modified_ct, &sk).expect("decap");
            let decap_bytes = kyber_ss_to_bytes(&decap);
            
            assert_ne!(decap_bytes.as_slice(), original_bytes.as_slice(),
                "üö® CT malleability at byte {}!", byte_pos);
        }
    }
    println!("‚úÖ Kyber odporne na CT malleability (50 bajt√≥w)");
}

// ============================================================
// KATEGORIA 5: RACE CONDITIONS
// ============================================================

#[test]
fn test_concurrent_key_generation() {
    use std::thread;
    use std::sync::Arc;
    use std::sync::atomic::{AtomicUsize, Ordering};
    
    let collision_count = Arc::new(AtomicUsize::new(0));
    let mut handles = Vec::new();
    
    for thread_id in 0..4 {
        let collisions = Arc::clone(&collision_count);
        handles.push(thread::spawn(move || {
            let mut keys = Vec::new();
            for i in 0..25 {
                let seed = format!("t{}_i{}", thread_id, i);
                let mut drbg = KmacDrbg::new(seed.as_bytes(), b"concurrent");
                let mut key = [0u8; 32];
                drbg.fill_bytes(&mut key);
                
                if keys.contains(&key) {
                    collisions.fetch_add(1, Ordering::SeqCst);
                }
                keys.push(key);
            }
            keys
        }));
    }
    
    let mut all = Vec::new();
    for h in handles { all.extend(h.join().unwrap()); }
    
    let unique: HashSet<_> = all.iter().collect();
    assert_eq!(unique.len(), 100, "Kolizje miƒôdzy wƒÖtkami!");
    println!("‚úÖ 4 wƒÖtki √ó 25 kluczy = 0 kolizji");
}

#[test]
fn test_concurrent_signing() {
    use std::thread;
    
    let (pk, sk) = falcon_keypair();
    let sk_bytes = falcon_sk_to_bytes(&sk).to_vec();
    let pk_bytes = falcon_pk_to_bytes(&pk).to_vec();
    
    let mut handles = Vec::new();
    
    for tid in 0..4u8 {
        let skb = sk_bytes.clone();
        let pkb = pk_bytes.clone();
        
        handles.push(thread::spawn(move || {
            let sk = tt_node::falcon_sigs::falcon_sk_from_bytes(&skb).unwrap();
            let pk = tt_node::falcon_sigs::falcon_pk_from_bytes(&pkb).unwrap();
            
            for i in 0..10u8 {
                let msg = [tid * 10 + i; 32];
                let sig = falcon_sign(&msg, &sk).expect("sign");
                assert!(falcon_verify(&msg, &sig, &pk).is_ok());
            }
        }));
    }
    
    for h in handles { h.join().expect("thread panic"); }
    println!("‚úÖ 40 podpis√≥w w 4 wƒÖtkach");
}

// ============================================================
// KATEGORIA 6: MESSAGE LENGTH ATTACKS
// ============================================================

#[test]
fn test_falcon_varying_sizes() {
    let (pk, sk) = falcon_keypair();
    
    let msg16 = [0xAA; 16];
    let msg32 = [0xBB; 32];
    let msg64 = [0xCC; 64];
    
    let sig16 = falcon_sign(&msg16, &sk).expect("sign16");
    let sig32 = falcon_sign(&msg32, &sk).expect("sign32");
    let sig64 = falcon_sign(&msg64, &sk).expect("sign64");
    
    assert!(falcon_verify(&msg16, &sig16, &pk).is_ok());
    assert!(falcon_verify(&msg32, &sig32, &pk).is_ok());
    assert!(falcon_verify(&msg64, &sig64, &pk).is_ok());
    
    assert!(falcon_verify(&msg32, &sig16, &pk).is_err());
    assert!(falcon_verify(&msg16, &sig64, &pk).is_err());
    println!("‚úÖ R√≥≈ºne rozmiary wiadomo≈õci OK");
}

#[test]
fn test_null_byte_injection() {
    let (pk, sk) = falcon_keypair();
    
    let with_nulls = [0x00, 0xAA, 0x00, 0xBB, 0x00, 0xCC, 0x00, 0xDD,
                     0x00, 0xAA, 0x00, 0xBB, 0x00, 0xCC, 0x00, 0xDD,
                     0x00, 0xAA, 0x00, 0xBB, 0x00, 0xCC, 0x00, 0xDD,
                     0x00, 0xAA, 0x00, 0xBB, 0x00, 0xCC, 0x00, 0xDD];
    let sig = falcon_sign(&with_nulls, &sk).expect("sign");
    
    assert!(falcon_verify(&[0x00u8], &sig, &pk).is_err());
    assert!(falcon_verify(&[0x00u8; 32], &sig, &pk).is_err());
    println!("‚úÖ Null byte injection blocked");
}

// ============================================================
// KATEGORIA 7: STATISTICAL BIAS
// ============================================================

#[test]
fn test_drbg_bit_distribution() {
    let mut drbg = KmacDrbg::new(b"stats_test_seed_xyz", b"stats");
    
    let mut bit_counts = [0u64; 256];
    let samples = 5000;
    
    for _ in 0..samples {
        let mut buf = [0u8; 32];
        drbg.fill_bytes(&mut buf);
        
        for (bi, &byte) in buf.iter().enumerate() {
            for bit in 0..8 {
                if byte & (1 << bit) != 0 {
                    bit_counts[bi * 8 + bit] += 1;
                }
            }
        }
    }
    
    let expected = samples as f64 / 2.0;
    let tolerance = expected * 0.15;
    
    let mut max_dev = 0.0f64;
    for &count in &bit_counts {
        let dev = (count as f64 - expected).abs();
        if dev > max_dev { max_dev = dev; }
        assert!(dev < tolerance, "Bit bias detected!");
    }
    
    println!("‚úÖ Rozk≈Çad bit√≥w OK (max dev: {:.1}%)", max_dev / expected * 100.0);
}

#[test]
fn test_kyber_ss_entropy() {
    let (pk, _) = kyber_keypair();
    
    let mut all_bytes = Vec::new();
    for _ in 0..50 {
        let (ss, _) = kyber_encapsulate(&pk);
        all_bytes.extend_from_slice(&kyber_ss_to_bytes(&ss));
    }
    
    let mut hist = [0u64; 256];
    for &b in &all_bytes { hist[b as usize] += 1; }
    
    let non_zero = hist.iter().filter(|&&c| c > 0).count();
    assert!(non_zero > 200, "Za ma≈Ço r√≥≈ºnych bajt√≥w: {}/256", non_zero);
    println!("‚úÖ Kyber SS entropia OK ({}/256)", non_zero);
}

// ============================================================
// KATEGORIA 8: BOUNDARY CONDITIONS
// ============================================================

#[test]
fn test_empty_message() {
    let (pk, sk) = falcon_keypair();
    
    let empty: [u8; 0] = [];
    let sig = falcon_sign(&empty, &sk).expect("sign empty");
    assert!(falcon_verify(&empty, &sig, &pk).is_ok());
    
    assert!(falcon_verify(&[0u8], &sig, &pk).is_err());
    println!("‚úÖ Pusta wiadomo≈õƒá OK");
}

#[test]
fn test_single_bit_differences() {
    let (pk, sk) = falcon_keypair();
    
    let base = [0xFF; 32];
    let sig = falcon_sign(&base, &sk).expect("sign");
    
    for byte in 0..32 {
        for bit in 0..8 {
            let mut modified = base;
            modified[byte] ^= 1 << bit;
            
            assert!(falcon_verify(&modified, &sig, &pk).is_err(),
                "Bit {}:{} not detected!", byte, bit);
        }
    }
    println!("‚úÖ 256 jednobitowych zmian wykrytych");
}

// ============================================================
// KATEGORIA 9: KEY SERIALIZATION ROUND-TRIP
// ============================================================

#[test]
fn test_falcon_key_serialization() {
    let (pk, sk) = falcon_keypair();
    
    let pk_bytes = pk.as_bytes();
    let sk_bytes = falcon_sk_to_bytes(&sk);
    
    let pk2 = tt_node::falcon_sigs::falcon_pk_from_bytes(pk_bytes).unwrap();
    let sk2 = tt_node::falcon_sigs::falcon_sk_from_bytes(&sk_bytes).unwrap();
    
    // Podpisz oryginalnym kluczem, zweryfikuj zdeserializowanym
    let msg = [0x42u8; 32];
    let sig = falcon_sign(&msg, &sk).unwrap();
    assert!(falcon_verify(&msg, &sig, &pk2).is_ok());
    
    // Podpisz zdeserializowanym, zweryfikuj oryginalnym
    let sig2 = falcon_sign(&msg, &sk2).unwrap();
    assert!(falcon_verify(&msg, &sig2, &pk).is_ok());
    
    println!("‚úÖ Falcon key round-trip OK");
}

#[test]
fn test_kyber_key_serialization() {
    let (pk, sk) = kyber_keypair();
    
    let pk_bytes = tt_node::kyber_kem::kyber_pk_to_bytes(&pk);
    let sk_bytes = tt_node::kyber_kem::kyber_sk_to_bytes(&sk);
    
    let pk2 = tt_node::kyber_kem::kyber_pk_from_bytes(pk_bytes).unwrap();
    let sk2 = tt_node::kyber_kem::kyber_sk_from_bytes(&sk_bytes).unwrap();
    
    // Encapsulate z oryginalnym PK, dekapsuluj z zdeserializowanym SK
    let (ss1, ct) = kyber_encapsulate(&pk);
    let ss1_dec = kyber_decapsulate(&ct, &sk2).unwrap();
    assert_eq!(kyber_ss_to_bytes(&ss1).as_slice(), kyber_ss_to_bytes(&ss1_dec).as_slice());
    
    // Encapsulate z zdeserializowanym PK, dekapsuluj z oryginalnym SK
    let (ss2, ct2) = kyber_encapsulate(&pk2);
    let ss2_dec = kyber_decapsulate(&ct2, &sk).unwrap();
    assert_eq!(kyber_ss_to_bytes(&ss2).as_slice(), kyber_ss_to_bytes(&ss2_dec).as_slice());
    
    println!("‚úÖ Kyber key round-trip OK");
}

// ============================================================
// PODSUMOWANIE
// ============================================================

#[test]
fn test_summary() {
    println!("\n");
    println!("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó");
    println!("‚ïë        DEEP VULNERABILITY HUNT - 20 TEST√ìW                   ‚ïë");
    println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
    println!("‚ïë  1. State Confusion      - DRBG massive gen, reseed, pers    ‚ïë");
    println!("‚ïë  2. Key Reuse            - Cross-verify, unique encaps       ‚ïë");
    println!("‚ïë  3. Entropy Starvation   - Weak seed, personalization        ‚ïë");
    println!("‚ïë  4. Malleability         - Signature & ciphertext integrity  ‚ïë");
    println!("‚ïë  5. Race Conditions      - Concurrent keygen & signing       ‚ïë");
    println!("‚ïë  6. Message Length       - Varying sizes, null injection     ‚ïë");
    println!("‚ïë  7. Statistical Bias     - DRBG distribution, SS entropy     ‚ïë");
    println!("‚ïë  8. Boundary Conditions  - Empty msg, single-bit changes     ‚ïë");
    println!("‚ïë  9. Key Serialization    - Falcon & Kyber round-trip         ‚ïë");
    println!("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£");
    println!("‚ïë         \"Paranoja to zaw√≥d - testujemy wszystko\"              ‚ïë");
    println!("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù");
}
