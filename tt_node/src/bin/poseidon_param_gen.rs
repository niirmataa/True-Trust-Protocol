// tt_node/src/bin/poseidon_param_gen.rs
#![forbid(unsafe_code)]

//! Generator parametrów Poseidona dla pola f128 (Winterfell).
//!
//! Użycie (w WSL / Linux):
//!   cd tt_node
//!   cargo run --bin poseidon_param_gen --features poseidon_param_gen \
//!       > src/crypto/poseidon_params.rs
//!
//! Wygenerowany plik: src/crypto/poseidon_params.rs
//! eksportuje:
//!   - POSEIDON_WIDTH
//!   - FULL_ROUNDS
//!   - PARTIAL_ROUNDS
//!   - TOTAL_ROUNDS
//!   - SBOX_EXP
//!   - ROUND_CONSTANTS
//!   - MDS_MATRIX
//!
//! Parametry są deterministyczne, NUMS-ish, generowane z SHA3-256
//! + prostą macierzą Cauchy’ego jako MDS.

use sha3::{Digest, Sha3_256};
use winterfell::math::{fields::f128::BaseElement, FieldElement, StarkField};

const POSEIDON_WIDTH: usize = 8;
const FULL_ROUNDS: usize = 8;
const PARTIAL_ROUNDS: usize = 60;
const TOTAL_ROUNDS: usize = FULL_ROUNDS + PARTIAL_ROUNDS;
const SBOX_EXP: u32 = 5;

// ---------------------- ROUND CONSTANTS -------------------------------------

fn generate_round_constants() -> Vec<BaseElement> {
    let mut result = Vec::with_capacity(TOTAL_ROUNDS * POSEIDON_WIDTH);

    let mut ctr: u64 = 0;
    while result.len() < TOTAL_ROUNDS * POSEIDON_WIDTH {
        let mut hasher = Sha3_256::new();
        hasher.update(b"TT_POSEIDON_RC_F128_V1");
        hasher.update(ctr.to_le_bytes());
        let h = hasher.finalize();

        // bierzemy 8 bajtów -> u64 -> u128 -> element pola
        let mut b = [0u8; 8];
        b.copy_from_slice(&h[..8]);
        let v_u64 = u64::from_le_bytes(b);
        let v = v_u64 as u128;
        result.push(BaseElement::new(v));

        ctr = ctr.wrapping_add(1);
    }

    result
}

// ---------------------- MDS Cauchy -----------------------------------------

fn generate_mds_matrix() -> [[BaseElement; POSEIDON_WIDTH]; POSEIDON_WIDTH] {
    // x_i = i+1, y_j = t + j + 1
    let t: u64 = POSEIDON_WIDTH as u64;

    let xs: Vec<BaseElement> = (0..t)
        .map(|i| BaseElement::new(((i + 1) as u128)))
        .collect();
    let ys: Vec<BaseElement> = (0..t)
        .map(|j| BaseElement::new(((t + j + 1) as u128)))
        .collect();

    let mut m = [[BaseElement::new(0u128); POSEIDON_WIDTH]; POSEIDON_WIDTH];

    for i in 0..POSEIDON_WIDTH {
        for j in 0..POSEIDON_WIDTH {
            let denom = xs[i] + ys[j];
            m[i][j] = denom.inv(); // 1 / (x_i + y_j)
        }
    }

    m
}

// -------------------------- EMISJA RUSTA -----------------------------------

fn main() {
    let round_constants = generate_round_constants();
    let mds = generate_mds_matrix();

    // Nagłówek + importy.
    println!("// This file is AUTO-GENERATED by src/bin/poseidon_param_gen.rs");
    println!("// DO NOT EDIT BY HAND.\n");
    println!("#![forbid(unsafe_code)]\n");
    println!("use winterfell::math::{{fields::f128::BaseElement, FieldElement}};\n");

    // Stałe konfiguracyjne.
    println!("pub const POSEIDON_WIDTH: usize = {};", POSEIDON_WIDTH);
    println!("pub const FULL_ROUNDS: usize = {};", FULL_ROUNDS);
    println!("pub const PARTIAL_ROUNDS: usize = {};", PARTIAL_ROUNDS);
    println!("pub const TOTAL_ROUNDS: usize = FULL_ROUNDS + PARTIAL_ROUNDS;");
    println!("pub const SBOX_EXP: u32 = {};\n", SBOX_EXP);

    // ROUND_CONSTANTS
    println!(
        "pub const ROUND_CONSTANTS: [[BaseElement; POSEIDON_WIDTH]; TOTAL_ROUNDS] = ["
    );
    for r in 0..TOTAL_ROUNDS {
        print!("    [");
        for c in 0..POSEIDON_WIDTH {
            let fe = round_constants[r * POSEIDON_WIDTH + c];
            let v = fe.as_int(); // u128
            print!("BaseElement::new({})", v);
            if c + 1 != POSEIDON_WIDTH {
                print!(", ");
            }
        }
        println!("],");
    }
    println!("];\n");

    // MDS_MATRIX
    println!(
        "pub const MDS_MATRIX: [[BaseElement; POSEIDON_WIDTH]; POSEIDON_WIDTH] = ["
    );
    for i in 0..POSEIDON_WIDTH {
        print!("    [");
        for j in 0..POSEIDON_WIDTH {
            let fe = mds[i][j];
            let v = fe.as_int(); // u128
            print!("BaseElement::new({})", v);
            if j + 1 != POSEIDON_WIDTH {
                print!(", ");
            }
        }
        println!("],");
    }
    println!("];");
}
